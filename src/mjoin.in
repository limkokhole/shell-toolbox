#!/bin/sh

# Part of @PACKAGE_STRING@
# For bug reports, see "@PACKAGE_BUGREPORT@"

utility_name=mjoin

# Variables set by the configure script:
AWK="@AWK@"
MKTEMP="@MKTEMP@"
JOIN="@JOIN@"
HAVE_GNU_JOIN="@HAVE_GNU_JOIN@"


do_join () {
    if [ "$HAVE_GNU_JOIN" = "yes" ]; then
        # Use the "-o auto" option of GNU join
        "$JOIN" -o auto "$@"
    else
        # Construct the appropriate "-o" option using awk
        # FIXME: The join(1) on OpenBSD has a bug.
        # https://marc.info/?l=openbsd-bugs&m=153889973013427&q=raw
        echo bum >&2
        exit 1
    fi
}

# Default values
delim=','   # Delimit fields on commas
field='1'   # Join on first field

# Do a full outer join by default
left='-a1'
right='-a2'

do_sort=0       # Assume input is sorted
do_auto_sort=0  # Don't do auto-detection of unsorted data

# Override the above defaults with options given to us by the user
# on the command line.
while getopts 'd:f:j:sS' opt; do
    case "$opt" in
        d) delim="$OPTARG" ;;
        f) field="$OPTARG" ;;
        j)
            case "$OPTARG" in
                inner) left=''   ; right=''    ;;
                left)  left='-a1'; right=''    ;;
                right) left=''   ; right='-a2' ;;
                full)  left='-a1'; right='-a2' ;;
                *) printf 'Unknown join type "%s",\n' "$OPTARG" >&2
                   echo 'Expected one of inner, left, right, or full' >&2
                   exit 1
            esac ;;
        s) do_sort=1
           do_auto_sort=0 ;;
        S) do_auto_sort=1 ;;
        *) echo 'Error in command line parsing' >&2
           exit 1
    esac
done

shift "$(( OPTIND - 1 ))"

# Sanity check
if [ "$#" -lt 2 ]; then
    echo 'Expected at least two files' >&2
    exit 1
fi

# Temporary files
result=$("$MKTEMP")  # The result of a join
tmpfile=$("$MKTEMP") # Temporary file holding a previous result

# Remove temporary files on exit
trap 'rm -f "$result" "$tmpfile"' EXIT

# Sort the first file if requested or needed
if  [ "$do_sort" -eq 1 ] ||
    [ "$do_auto_sort" -eq 1 ] &&
    ! sort -C -t "$delim" -k"$field,$field" "$1"
then
    sort -t "$delim" -k"$field,$field" -o "$tmpfile" "$1"
else
    cp "$1" "$tmpfile"
fi

# Join the first two files, sorting the second file if requested or needed
if  [ "$do_sort" -eq 1 ] ||
    [ "$do_auto_sort" -eq 1 ] &&
    ! sort -C -t "$delim" -k"$field,$field" "$2"
then
    sort -t "$delim" -k"$field,$field" "$2"
else
    cat "$2"
fi |
do_join -t "$delim" -j "$field" \
    ${left:+"$left"} ${right:+"$right"} "$tmpfile" - >"$result"

shift 2

# Loop over the remaining files, adding to the result with each file
for pathname do
    mv "$result" "$tmpfile"

    # Note: $tmpfile would already be sorted and the join field is the
    #       first field in that file.

    if [ "$do_sort" -eq 1 ] ||
        [ "$do_auto_sort" -eq 1 ] &&
        ! sort -C -t "$delim" -k "$field,$field" "$pathname"
    then
        sort -t "$delim" -k "$field,$field" "$pathname"
    else
        cat "$pathname"
    fi |
    do_join -t "$delim" -2 "$field" \
        ${left:+"$left"} ${right:+"$right"} "$tmpfile" - >"$result"
done

# Done, output result
cat "$result"
